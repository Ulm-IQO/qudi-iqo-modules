#  Example Qudi configuration file.

global:
    # list of modules to load when starting
    startup: []

    # Module server configuration for accessing qudi GUI/logic/hardware modules from remote clients
    remote_modules_server:
        address: 'localhost'
        port: 5901

    # Server port for serving the active qudi module namespace locally (localhost).
    # Used by e.g. the Qudi jupyter kernel.
    namespace_server_port: 18861

    # If this flag is set (True), all arguments passed to qudi module APIs from remote
    # (jupyter notebook, qudi console, remote modules) will be wrapped and passed "per value"
    # (serialized and de-serialized). This is avoiding a lot of inconveniences with using numpy in
    # remote clients.
    # If you do not want to use this workaround and know what you are doing, you can disable this
    # feature by setting this flag to False.
    force_remote_calls_by_value: True

    # Qss stylesheet for controlling the appearance of the GUIs.
    # Absolute path or relative to qudi.artwork.styles
    stylesheet: 'qdark.qss'

    # Default root directory for measurement data storage. All eventual data sub-directories should
    # be contained within this directory. This is not enforced, just convention.
    # The fallback directory is <user home>/qudi/Data/

    # Save data to daily data sub-directories by default
    daily_data_dirs: True

gui:
    dummy_confocal:
        module.Class: 'scanning.scannergui.ScannerGui'
        connect:
            scanning_logic: 'scanning_logic'
            data_logic: 'data_logic'
            optimize_logic: 'optimize_logic'

    ni_confocal:
        module.Class: 'scanning.scannergui.ScannerGui'
        connect:
            scanning_logic: 'scanning_logic_ni'
            data_logic: 'data_logic_ni'
            optimize_logic: 'optimize_logic_ni'

    time_series_gui:
        module.Class: 'time_series.time_series_gui.TimeSeriesGui'
        use_antialias: True  # optional, set to False if you encounter performance issues
        connect:
            _time_series_logic_con: 'time_series_reader_logic'

    qdplotter:
        module.Class: 'qdplot.qdplot_gui.QDPlotterGui'
        pen_color_list: [[100, 100, 100], 'c', 'm', 'g']
        connect:
            qdplot_logic: 'qdplotlogic'

    odmr_gui:
        module.Class: 'odmr.odmrgui.OdmrGui'
        connect:
            odmr_logic: 'odmr_logic'

logic:

    scanning_logic:
        module.Class: 'scanning_probe_logic.ScanningProbeLogic'
        min_poll_interval: 0.1
        connect:
            scanner: 'scanner_dummy'

    scanning_logic_ni:
        module.Class: 'scanning_probe_logic.ScanningProbeLogic'
        min_poll_interval: 0.1
        connect:
            scanner: 'ni_scanning_probe'

    data_logic:
        module.Class: 'scanning_data_logic.ScanningDataLogic'
        connect:
            scan_logic: 'scanning_logic'

    data_logic_ni:
        module.Class: 'scanning_data_logic.ScanningDataLogic'
        connect:
            scan_logic: 'scanning_logic_ni'

    optimize_logic:
        module.Class: 'scanning_optimize_logic.ScanningOptimizeLogic'
        connect:
            scan_logic: 'scanning_logic'

    optimize_logic_ni:
        module.Class: 'scanning_optimize_logic.ScanningOptimizeLogic'
        connect:
            scan_logic: 'scanning_logic_ni'

    time_series_reader_logic:
        module.Class: 'time_series_reader_logic.TimeSeriesReaderLogic'
        max_frame_rate: 10  # optional (10Hz by default)
        calc_digital_freq: True  # optional (True by default)
        connect:
            streamer: 'nicard_6323_instreamer'

    qdplotlogic:
        module.Class: 'qdplot_logic.QDPlotLogic'
        default_plot_number: 3

    odmr_logic:
        module.Class: 'odmr_logic.OdmrLogic'
        connect:
            microwave: 'microwave_dummy'
            data_scanner: 'finite_sampling_input_dummy'

hardware:
    ni_scanning_probe:
        module.Class: 'interfuse.ni_scanning_probe_interfuse.NiScanningProbeInterfuse'
        connect:
            scan_hardware: 'ni_finite_sampling_io'
            analog_output: 'ni_ao'
        ni_channel_mapping:
            x: 'ao0'
            y: 'ao1'
            z: 'ao2'
            APD1: 'PFI8'
            APD2: 'PFI9'
            AI0: 'ai0'
        position_ranges: # in m
            x: [-100e-6, 100e-6]
            y: [0, 200e-6]
            z: [-100e-6, 100e-6]
        frequency_ranges: #Aka values written/retrieved per second; Check with connected HW for sensible constraints.
            x: [1, 5000]
            y: [1, 5000]
            z: [1, 1000]
        resolution_ranges:
            x: [1, 10000]
            y: [1, 10000]
            z: [2, 1000]
        input_channel_units:
            APD1: 'c/s'
            APD2: 'c/s'
            AI0: 'V'
        backwards_line_resolution: 50 # optional
        move_velocity: 400e-6 #m/s; This speed is used for scanner movements and avoids jumps from position to position.

    scanner_dummy:
        module.Class: 'dummy.scanning_probe_dummy.ScanningProbeDummy'
        position_ranges:
            x: [0, 200e-6]
            y: [0, 200e-6]
            z: [-100e-6, 100e-6]
            a: [-100e-6, 100e-6]
        frequency_ranges:
            x: [1, 5000]
            y: [1, 5000]
            z: [1, 1000]
            a: [1, 1000]
        resolution_ranges:
            x: [1, 10000]
            y: [1, 10000]
            z: [2, 1000]
            a: [2, 1000]
        position_accuracy:
            x: 10e-9
            y: 10e-9
            z: 50e-9
            a: 50e-9
        require_square_pixels: True

    ni_finite_sampling_io:
        module.Class: 'ni_x_series.ni_x_series_finite_sampling_io.NIXSeriesFiniteSamplingIO'
        device_name: 'Dev1'
        input_channel_units:
            PFI8: 'c/s'
            PFI9: 'c/s'
            ai0: 'V'
            ai1: 'V'
        output_channel_units: # Specify used output channels
            'ao0': 'V'
            'ao1': 'V'
            'ao2': 'V'
            'ao3': 'V'
        adc_voltage_ranges:
            ai0: [-10, 10]  # optional
            ai1: [-10, 10]  # optional
        output_voltage_ranges:
            ao0: [-1.5, 1.5]
            ao1: [-1.5, 1.5]
            ao2: [0, 10.0]
            ao3: [-10.0, 10.0]
        frame_size_limits: [1, 1e9]  # optional #TODO actual HW constraint?
        default_output_mode: 'JUMP_LIST' # optional, must be name of SamplingOutputMode
        read_write_timeout: 10  # optional
        sample_clock_output: '/Dev1/PFI11' # optional: routing of sample clock to a physical connection

    ni_ao:
        module.Class: 'ni_x_series.ni_x_series_analog_output.NIXSeriesAnalogOutput'
        device_name: 'Dev1'

        setpoint_channels:
            ao0:
                unit: 'V'
                limits: [-1.5, 1.5]
                keep_value: True
            ao1:
                unit: 'V'
                limits: [-1.5, 1.5]
                keep_value: True
            ao2:
                unit: 'V'
                limits: [0, 10]
                keep_value: True
            ao3:
                unit: 'V'
                limits: [-10, 10]
                keep_value: True

    nicard_6323_instreamer:
        module.Class: 'ni_x_series.ni_x_series_in_streamer.NIXSeriesInStreamer'
        device_name: 'Dev1'
        digital_sources:  # optional
            - 'PFI8'
        analog_sources:  # optional
            - 'ai0'
            - 'ai1'
        # external_sample_clock_source: 'PFI0'  # optional
        # external_sample_clock_frequency: 1000  # optional
        adc_voltage_range: [-10, 10]  # optional
        max_channel_samples_buffer: 10000000  # optional
        read_write_timeout: 10  # optional

    finite_sampling_input_dummy:
        module.Class: 'dummy.finite_sampling_input_dummy.FiniteSamplingInputDummy'
        simulation_mode: 'ODMR'
        sample_rate_limits: [1, 1e6]
        frame_size_limits: [1, 1e9]
        channel_units:
            'APD counts': 'c/s'
            'Photodiode': 'V'

    instream_dummy:
        module.Class: 'dummy.data_instream_dummy.InStreamDummy'
        digital_channels:  # optional, must provide at least one digital or analog channel
            - 'digital 1'
            - 'digital 2'
            - 'digital 3'
        analog_channels:  # optional, must provide at least one digital or analog channel
            - 'analog 1'
            - 'analog 2'
        digital_event_rates:  # optional, must have as many entries as digital_channels or just one
            - 1000
            - 10000
            - 100000
        # digital_event_rates: 100000
        analog_amplitudes:  # optional, must have as many entries as analog_channels or just one
            - 5
            - 10
        # analog_amplitudes: 10  # optional (10V by default)

